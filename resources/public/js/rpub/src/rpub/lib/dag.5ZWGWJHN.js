import*as l from"cherry-cljs/cljs.core.js";import*as d from"rads.dependency";var _=function(a){const n=a,r=l.__destructure_map.call(null,n),t=l.get.call(null,r,l.keyword("rpub.lib.dag/nodes")),e=l.get.call(null,r,l.keyword("rpub.lib.dag/edges")),c=d.topo_sort.call(null,e);return l.into.call(null,l.array_map(),l.map.call(null,function(u){return l.vector(u,l.filter.call(null,d.transitive_dependents.call(null,e,u),c))},l.filter.call(null,function(u){return l.get_in.call(null,t,l.vector(u,l.keyword("push")))},d.nodes.call(null,e))))},g=function(a,n){return l.reduce.call(null,function(r,t){const e=t,c=l.nth.call(null,e,0,null),u=l.nth.call(null,e,1,null);return d.depend.call(null,r,u,c)},a,n)},v=function(a){const n=a,r=l.__destructure_map.call(null,n),t=l.get.call(null,r,l.keyword("nodes")),e=l.get.call(null,r,l.keyword("edges")),c=g.call(null,d.graph.call(null),e);return l.array_map(l.keyword("rpub.lib.dag/nodes"),t,l.keyword("rpub.lib.dag/edges"),c,l.keyword("rpub.lib.dag/values"),l.array_map(),l.keyword("rpub.lib.dag/dependents"),_.call(null,l.array_map(l.keyword("rpub.lib.dag/nodes"),t,l.keyword("rpub.lib.dag/edges"),c)))},b=function(a,n){const r=l.get_in.call(null,a,l.vector(l.keyword("rpub.lib.dag/nodes"),n,l.keyword("calc"))),t=l.assoc.call(null,l.keyword("rpub.lib.dag/acc").call(null,a),l.keyword("rpub.lib.dag/values"),l.keyword("rpub.lib.dag/values").call(null,a)),e=r.call(null,t);return l.assoc_in.call(null,a,l.vector(l.keyword("rpub.lib.dag/values"),n),e)},y=function(a,n){if(l.truth_.call(null,l.contains_QMARK_.call(null,l.keyword("rpub.lib.dag/nodes").call(null,a),n)))return null;throw l.ex_info.call(null,l.str.call(null,"Unknown node: ",n),l.array_map(l.keyword("node-key"),n))},w=(()=>{const a=function(n){switch(l.alength.call(null,arguments)){case 2:return a.cljs$core$IFn$_invoke$arity$2(arguments[0],arguments[1]);case 3:return a.cljs$core$IFn$_invoke$arity$3(arguments[0],arguments[1],arguments[2]);default:throw new Error(l.str.call(null,"Invalid arity: ",l.alength.call(null,arguments)))}};return a.cljs$core$IFn$_invoke$arity$2=function(n,r){return w.call(null,n,r,l.keyword("rpub.lib.dag/no-value"))},a.cljs$core$IFn$_invoke$arity$3=function(n,r,t){y.call(null,n,r);const e=l.get_in.call(null,n,l.vector(l.keyword("rpub.lib.dag/nodes"),r,l.keyword("push"))),c=l.get_in.call(null,n,l.vector(l.keyword("rpub.lib.dag/dependents"),r)),u=l.truth_.call(null,l._EQ_.call(null,t,l.keyword("rpub.lib.dag/no-value")))?l.update.call(null,n,l.keyword("rpub.lib.dag/acc"),e):l.update.call(null,n,l.keyword("rpub.lib.dag/acc"),e,t);return l.reduce.call(null,b,u,c)},a.cljs$lang$maxFixedArity=3,a})(),$=function(a,n,r,t){const e=g.call(null,l.keyword("rpub.lib.dag/edges").call(null,a),t),c=l.assoc.call(null,l.assoc_in.call(null,a,l.vector(l.keyword("rpub.lib.dag/nodes"),n),r),l.keyword("rpub.lib.dag/edges"),e);return b.call(null,l.assoc.call(null,c,l.keyword("rpub.lib.dag/dependents"),_.call(null,c)),n)},f=function(a,n){const r=l.update.call(null,l.update.call(null,a,l.keyword("rpub.lib.dag/nodes"),l.dissoc,n),l.keyword("rpub.lib.dag/edges"),d.remove_all,n);return l.assoc.call(null,r,l.keyword("rpub.lib.dag/dependents"),_.call(null,r))},m=function(a,n){const r=function(e,c){const u=function(s){const o=l.array.call(null),p=l.alength.call(null,arguments);let i=0;for(;;){if(i<p){o.push(arguments[i]),i=i+1;continue}break}const k=0<l.alength.call(null,o)?new l.IndexedSeq(o.slice(0),0,null):null;return u.cljs$core$IFn$_invoke$arity$variadic(k)};return u.cljs$core$IFn$_invoke$arity$variadic=function(s){const o=l.apply.call(null,c,s),p=l.array_map(l.keyword("key"),e,l.keyword("args"),s,l.keyword("ret"),o);return l.transduce.call(null,n,l.constantly.call(null,null),l.vector(p)),o},u.cljs$lang$maxFixedArity=0,u.cljs$lang$applyTo=function(s){return this.cljs$core$IFn$_invoke$arity$variadic(l.seq.call(null,s))},u},t=function(e,c){const u=c,s=l.truth_.call(null,l.keyword("calc").call(null,c))?l.update.call(null,u,l.keyword("calc"),function(o){return r.call(null,e,o)}):u;return l.truth_.call(null,l.keyword("push").call(null,c))?l.update.call(null,s,l.keyword("push"),function(o){return r.call(null,e,o)}):s};return l.update.call(null,a,l.keyword("rpub.lib.dag/nodes"),function(e){return l.into.call(null,l.array_map(),l.map.call(null,function(c){const u=c,s=l.nth.call(null,u,0,null),o=l.nth.call(null,u,1,null);return l.vector(s,t.call(null,s,o))},e))})};export{v as __GT_dag,g as add_edges,$ as add_node,y as assert_contains_node,_ as dependents,w as push,b as recalculate,f as remove_node,m as wrap_tracing};
